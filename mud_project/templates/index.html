<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Whispers in the Dark - Client</title>
    <style>
        /* ... (your existing CSS from index_html_v4_spacing_fix) ... */
        html, body {
            height: 100%; margin: 0; padding: 0;
            font-family: 'Courier New', Courier, monospace;
            background-color: #111; color: #ddd; overflow: hidden; 
        }
        #game-window { display: flex; flex-direction: column; height: 100%; width: 100%; }
        #stats-area {
            padding: 10px; border-bottom: 1px solid #444; font-size: 0.9em;
            background-color: #1a1a1a; white-space: pre-wrap; 
            flex-shrink: 0; line-height: 1.3;
        }
        #output {
            flex-grow: 1; overflow-y: auto; padding: 10px;
            border-bottom: 1px solid #444; 
            white-space: pre-wrap; 
            line-height: 1.4;
        }
        #input-area { 
            display: flex; 
            flex-direction: column; /* Stack input and RT bar */
            padding: 10px; 
            background-color: #1a1a1a; 
            flex-shrink: 0; 
        }
        #command-input-wrapper {
            display: flex; /* For input and button */
            width: 100%;
        }
        #input { /* Renamed from command-input for clarity */
            flex-grow: 1; background-color: #222; color: #ddd;
            border: 1px solid #444; padding: 8px;
            font-family: inherit; font-size: 1em;
        }
        #send-button { /* Added a send button for consistency if needed */
            background-color: #030; color: #0f0;
            border: 1px solid #070; padding: 8px 15px;
            margin-left: 10px; cursor: pointer;
        }
        #send-button:hover { background-color: #050; }

        .message-prefix {
            color: #888; 
            font-style: normal;  
            font-weight: normal; 
            margin-right: 0.5ch; 
        }
        /* Message Type Styling examples */
        .message-echo {} 
        .message-error, .message-error_rt, .message-error_critical, .message-error_pvp, .message-error_move, .message-error_dev { color: #ff6b6b; font-weight: bold; }
        .message-feedback, .message-feedback_move, .message-feedback_neutral, .message-feedback_get_item, .message-feedback_search_corpse, .message-feedback_search_empty, .message-feedback_look_target, .message-feedback_read  { color: #8fbc8f; } 
        .message-event_highlight, .message-system_highlight, .message-level_up_major, .message-event_pvp_victory, .message-event_pvp_defeat_major, .message-event_defeat_corpse, .message-event_defeat, .message-event_defeat_major  { color: #ffd700; font-weight: bold; } 
        .message-system, .message-prompt, .message-system_warning, .message-system_info, .message-system_info_block { color: #add8e6; } 
        .message-stat_increase { color: #40e0d0; } 
        .message-speech_player, .message-dialogue_self { color: #87cefa; font-style: italic; } 
        .message-speech_other, .message-dialogue_other { color: #dda0dd; font-style: italic; } 
        .message-ambient_npc, .message-ambient_monster, .message-ambient_other_player, .message-ambient_player_arrival, .message-ambient_player_departure, .message-ambient_combat, .message-ambient_pvp_defeat, .message-ambient_neutral, .message-ambient_spawn, .message-ambient_time, .message-ambient_weather { color: #a9a9a9; font-style: italic; }  
        .message-event_monster_arrival { color: #ff7f50; font-weight: bold; font-style: italic;} 
        .message-system_tick_marker { color: #666; } 
        .message-xp_gain, .message-xp_absorb, .message-xp_pool_full, .message-mind_status { color: #b8860b; } /* DarkGoldenRod for XP/Mind */
        .message-faction_update_positive { color: #32cd32; } /* LimeGreen */
        .message-faction_update_negative { color: #ff4500; } /* OrangeRed */
        .message-combat_action_player, .message-combat_hit_player, .message-combat_miss_player, .message-combat_defeat_player, .message-combat_status_target  { color: #ffaf7a; } /* Light Orange/Peach for player combat actions */
        .message-combat_roll_info_debug { color: #777; font-style: italic; font-size: 0.9em; } /* Greyed out for debug */
        .message-feedback_loot_drop { color: #4caf50; font-style: italic; } /* Green for loot drops */
        .message-header_info_block { color: #f0e68c; font-weight: bold; text-decoration: underline;} /* Khaki, bold, underline */
        .message-info_block_content { color: #e0e0e0; padding-left: 1ch;} /* Light grey, slight indent */

        
        /* Room info specific styling */
        .room-info-container { margin-bottom: 10px; } 
        .message-room_name_line { color: #00ffff; font-weight: bold; } 
        .message-room_description { color: #f0f8ff; margin-top: 0px; padding-left: 2ch; } 
        .message-room_presence_line { color: #e6e6fa; font-style: italic; } 
        .message-room_items_line { color: #98fb98; } 
        .message-room_exits_line { color: #fadadd; margin-top: 5px;} 
        
        #rt-bar-container {
            width: 100%; height: 10px; background-color: #333; 
            margin-top: 5px; border: 1px solid #555; border-radius: 3px;
            display: flex; overflow: hidden; opacity: 0; 
            transition: opacity 0.3s ease-in-out;
        }
        #rt-bar-container.active { opacity: 1; }
        .rt-tick {
            height: 100%; background-color: #c00; 
            border-right: 1px solid #500; box-sizing: border-box;
            transition: width 0.2s linear, opacity 0.3s linear; 
        }
        .rt-tick.fading { opacity: 0; width: 0 !important; }

    </style>
</head><body>
    <div id="game-window">
        <div class="stats-display" id="stats-area">
            Name: - | Lvl: - | XP: -/- (Pool: -)<br>HP: -/- | MP: -/- | SP: -/- | Gold: -<br>RT: -
        </div>
        <div id="output"></div>
        <div id="input-area">
            <div id="rt-bar-container">
                </div>
            <div id="command-input-wrapper">
                <input type="text" id="input" placeholder="Enter command..." autofocus>
                </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const socket = io();
        const output = document.getElementById('output');
        const commandInput = document.getElementById('input'); 
        const statsArea = document.getElementById('stats-area');
        const rtBarContainer = document.getElementById('rt-bar-container');

        const commandHistory = [];
        let historyIndex = -1;
        let rtIntervalId = null; 

        console.log("CLIENT: Script loaded.");

        function appendOutput(element) {
            const scrollThreshold = 30; 
            const isScrolledToBottom = output.scrollHeight - output.clientHeight <= output.scrollTop + scrollThreshold;
            output.appendChild(element);
            if (isScrolledToBottom) {
                output.scrollTop = output.scrollHeight;
            }
        }

        function createPrefixedMessageLine(text, type) {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'prefixed-line message-' + type; 
            const prefixSpan = document.createElement('span');
            prefixSpan.className = 'message-prefix';
            // Make the prefix conditional for room descriptions if they already contain it
            if (type === 'room_description' && text.startsWith('[')) { // Heuristic for room name lines
                 // No prefix for room name line itself if it's formatted like that
            } else if (type.startsWith('room_') && (type !== 'room_name_line' && type !== 'room_description')) {
                 // No prefix for other parts of room description if they are distinct lines
            } else if (type === 'room_name_line') {
                // No prefix for the room name itself.
            }
            else {
                prefixSpan.textContent = '>'; 
                lineDiv.appendChild(prefixSpan);
            }
            const textNode = document.createTextNode(text); 
            lineDiv.appendChild(textNode);
            return lineDiv;
        }

        function addMessage(text, type = 'normal') {
            const messageText = (text === null || text === undefined) ? String(text) : text;

            if (type === 'echo') { 
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message-' + type;
                const prefixSpan = document.createElement('span');
                prefixSpan.className = 'message-prefix';
                prefixSpan.textContent = '>';
                messageDiv.appendChild(prefixSpan);
                // For echo, text already includes "> ", so remove it from messageText before appending
                messageDiv.appendChild(document.createTextNode(String(messageText).startsWith("> ") ? String(messageText).substring(2) : String(messageText))); 
                appendOutput(messageDiv);
                return;
            }
             if (type === 'system_tick_marker' && messageText === '>') { // For player's own tick marker
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message-' + type; 
                const prefixSpan = document.createElement('span');
                prefixSpan.className = 'message-prefix'; 
                prefixSpan.textContent = '>'; // This is the actual marker text
                messageDiv.appendChild(prefixSpan);
                // No additional text needed for this specific marker type
                appendOutput(messageDiv);
                return;
            }

            if (type === 'error_rt' && messageText.toLowerCase().startsWith('wait')) {
                const waitTimeMatch = messageText.match(/wait\s*([\d.]+)\s*s/i);
                if (waitTimeMatch && waitTimeMatch[1]) {
                    const durationSeconds = parseFloat(waitTimeMatch[1]);
                    startRoundTimeBar(durationSeconds);
                }
            }
            
            // For other messages, split by newline and process each line
            const lines = String(messageText).split('\n'); 
            lines.forEach(line => {
                // Adjust prefixing for room info lines
                if (type.startsWith('room_')) {
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'message-' + type;
                    // No ">" prefix for specific room lines
                    lineDiv.textContent = line;
                    appendOutput(lineDiv);
                } else {
                    appendOutput(createPrefixedMessageLine(line, type));
                }
            });
        }
        
        function displayRoomInfo(roomData) { 
            if (!roomData || typeof roomData !== 'object') { 
                console.error("CLIENT: displayRoomInfo called with invalid data:", roomData);
                addMessage("Error: Received invalid room data from server.", "error_critical");
                return;
            }
            // Display room name without ">"
            const roomNameDiv = document.createElement('div');
            roomNameDiv.className = 'message-room_name_line';
            roomNameDiv.textContent = `[${roomData.name || 'Unknown Room'}]`;
            appendOutput(roomNameDiv);

            // Display room description without ">"
            const descDiv = document.createElement('div');
            descDiv.className = 'message-room_description';
            descDiv.textContent = roomData.description || 'No description available.';
            appendOutput(descDiv);
            
            // Display presence summary (ALSO HERE) without ">"
            if (roomData.presence_summary && roomData.presence_summary.length > 0) { 
                const presenceDiv = document.createElement('div');
                presenceDiv.className = 'message-room_presence_line';
                presenceDiv.textContent = roomData.presence_summary;
                appendOutput(presenceDiv);
            }
            // Display items summary (YOU ALSO SEE) without ">"
            if (roomData.items_summary && roomData.items_summary.length > 0) {
                 const itemsDiv = document.createElement('div');
                 itemsDiv.className = 'message-room_items_line';
                 itemsDiv.textContent = roomData.items_summary; // Directly use the pre-formatted string
                 appendOutput(itemsDiv);
            }
            // Display exits without ">"
            const exitsDiv = document.createElement('div');
            exitsDiv.className = 'message-room_exits_line';
            exitsDiv.textContent = `OBVIOUS EXITS: ${roomData.exits || 'None'}`;
            appendOutput(exitsDiv);
        }

        function displayRaceOptions(racePayload) { 
            if (!racePayload || typeof racePayload !== 'object') {
                console.error("CLIENT: displayRaceOptions called with invalid data:", racePayload);
                addMessage("Error: Received invalid race data from server.", "error_critical");
                return;
            }
            if (racePayload.prompt_text) {
                 addMessage(racePayload.prompt_text, 'prompt'); 
            }
            if (racePayload.races && Array.isArray(racePayload.races)) {
                addMessage("--- Available Heritages ---", "system_highlight");
                racePayload.races.forEach(race => {
                    addMessage(`${race.name.toUpperCase()} (Type: ${race.key})`, 'system_highlight');
                    addMessage(`  ${race.description}`, 'info'); 
                    if (race.stat_modifiers_display && typeof race.stat_modifiers_display === 'object' && Object.keys(race.stat_modifiers_display).length > 0) {
                        let modifiersStr = Object.entries(race.stat_modifiers_display)
                            .map(([stat, val_str]) => `${stat.toUpperCase()} ${val_str}`) // val_str is already formatted like "+X" or "-Y"
                            .join(', ');
                        addMessage(`  Stat Modifiers: ${modifiersStr}`, 'feedback');
                    }
                    if (race.notes) { // Changed from lore_snippet to notes to match creation.py
                        addMessage(`  "${race.notes}"`, 'narrative_emotive');
                    }
                    const spacer = document.createElement('div'); 
                    spacer.innerHTML = '&nbsp;'; // Ensures a visual line break
                    appendOutput(spacer); 
                });
                addMessage("---------------------------", "system_highlight");
            } else {
                addMessage("No race options available at this time.", "system_info");
            }
        }

        function startRoundTimeBar(durationSeconds) {
            if (rtIntervalId) {
                clearInterval(rtIntervalId); 
            }
            rtBarContainer.innerHTML = ''; 
            rtBarContainer.classList.add('active');
            commandInput.disabled = true; 

            const totalTicks = Math.max(1, Math.ceil(durationSeconds * 5)); // More ticks for smoother look (e.g., 5 per sec)
            const tickDurationMs = (durationSeconds * 1000) / totalTicks;
            
            for (let i = 0; i < totalTicks; i++) {
                const tickElement = document.createElement('div');
                tickElement.className = 'rt-tick';
                tickElement.style.width = `${100 / totalTicks}%`; 
                rtBarContainer.appendChild(tickElement);
            }

            let ticksToRemove = totalTicks;
            rtIntervalId = setInterval(() => {
                const ticks = rtBarContainer.querySelectorAll('.rt-tick:not(.fading)');
                if (ticks.length > 0) {
                    ticks[ticks.length - 1].classList.add('fading'); 
                }
                ticksToRemove--;
                if (ticksToRemove <= 0) {
                    clearInterval(rtIntervalId);
                    rtIntervalId = null;
                    setTimeout(() => { 
                        rtBarContainer.classList.remove('active');
                        rtBarContainer.innerHTML = ''; 
                        commandInput.disabled = false;
                        commandInput.focus();
                        console.log("CLIENT: Round time finished.");
                    }, 300); 
                }
            }, tickDurationMs);
        }


        commandInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                const command = commandInput.value;
                if (command && !commandInput.disabled) { 
                    if (commandHistory.length === 0 || command !== commandHistory[commandHistory.length - 1]) {
                        commandHistory.push(command);
                    }
                    if (commandHistory.length > 20) commandHistory.shift(); 
                    historyIndex = commandHistory.length;
                    socket.emit('player_command', { command: command });
                    commandInput.value = '';
                }
            }
        });
        commandInput.addEventListener('keydown', (event) => {
            if (commandInput.disabled && (event.key === 'ArrowUp' || event.key === 'ArrowDown')) {
                event.preventDefault(); return; 
            }
            if (commandHistory.length === 0 && (event.key === 'ArrowUp' || event.key === 'ArrowDown')) {
                 event.preventDefault(); return;
            }
            if (event.key === 'ArrowUp') {
                event.preventDefault(); 
                if (historyIndex > 0) {
                    historyIndex--;
                    commandInput.value = commandHistory[historyIndex] || '';
                    commandInput.setSelectionRange(commandInput.value.length, commandInput.value.length);
                } else if (historyIndex === 0 && commandHistory.length > 0) {
                    commandInput.value = commandHistory[0] || ''; 
                    commandInput.setSelectionRange(commandInput.value.length, commandInput.value.length);
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    commandInput.value = commandHistory[historyIndex] || '';
                } else { 
                     historyIndex = commandHistory.length; 
                     commandInput.value = ''; 
                }
                commandInput.setSelectionRange(commandInput.value.length, commandInput.value.length);
            }
        });

        socket.on('connect', () => { console.log("CLIENT: Socket connected. SID:", socket.id); });
        socket.on('disconnect', (reason) => { 
            console.error("CLIENT: Socket disconnected. Reason:", reason);
            addMessage(`Disconnected from server. Reason: ${reason}`, 'error_critical'); 
            if (rtIntervalId) clearInterval(rtIntervalId); 
            rtBarContainer.classList.remove('active');
            commandInput.disabled = false;
        });
        socket.on('connect_error', (error) => {
            console.error("CLIENT: Socket connection error:", error);
            addMessage(`Connection error: ${error.message || error}`, 'error_critical');
        });

        socket.on('game_messages', (data) => {
            console.log("CLIENT: Received 'game_messages' batch:", data);
            if (data.messages && Array.isArray(data.messages)) {
                data.messages.forEach(msg => {
                    console.log("CLIENT: Processing message object:", msg);
                    if (msg.type === 'room_data_update') {
                        displayRoomInfo(msg); 
                    } else if (msg.type === 'display_race_options') {
                        displayRaceOptions(msg); 
                    } else if (msg.text !== undefined) { 
                        addMessage(msg.text, msg.type || 'normal');
                    } else {
                        console.warn("CLIENT: Received unhandled structured message (no .text and not a known special type):", msg);
                    }
                });
            } else {
                console.warn("CLIENT: Received 'game_messages' but data.messages is not a valid array:", data);
            }
        });
        
        socket.on('stats_update', (data) => {
            console.log("CLIENT: Received 'stats_update':", data);
            if (data && data.raw_stats && typeof data.raw_stats === 'object') { 
                let statsText = `Name: ${data.raw_stats.name || '-'} | Lvl: ${data.raw_stats.level || '-'} | XP: ${data.raw_stats.xp || '-'}/- (Pool: ${data.raw_stats.unabsorbed_xp || 0})<br>HP: ${data.raw_stats.hp || '-'}/${data.raw_stats.max_hp || '-'} | MP: ${data.raw_stats.mp || '-'}/${data.raw_stats.max_mp || '-'} | SP: ${data.raw_stats.sp || '-'}/${data.raw_stats.max_sp || '-'} | Gold: -<br>Mind: ${data.raw_stats.mind_status || '-'}`;
                statsArea.innerHTML = statsText; 
            }
        });
        socket.on('error_message', (data) => { 
            console.error("CLIENT: Received 'error_message':", data);
            addMessage(`SERVER ERROR: ${data.message}`, 'error_critical'); 
        });
        
        window.onload = () => { 
            console.log("CLIENT: Window loaded. Focusing input.");
            commandInput.focus(); 
            addMessage("Connecting to server...", "system"); 
        };
    </script>
</body>
</html>